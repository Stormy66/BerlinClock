Berlin Clock

Documentation - All classes have appropriate javadoc. I have followed the pattern whereby private methods are not documented unless complex enough to require it. Duplication has been minimised so where the @param or @return would be very similar to the main text, the main text has been omitted. Javadoc has been entirely omitted for JUnits and the method names should be sufficient to convey the intention.

My implementation of the Berlin Clock has tried to respect the MVC design pattern has much as possible. I have coded against interfaces as much as possible. There are three main classes each following an interface DefaultClockManager(the model), the BerlinClockController(controller) and the TextBerlinClockView (view).

The TextBerlinClockView implements the BerlinClockView which provides a series of methods that will be exposed to utilising classes. By programming against this interface I ensure that the concrete TextBerlinClockView class could easily be swapped out for another implementation of the BerlincClockView and the controller would not need to be changed.

The view contains absolutely no business logic. A lot of the design decisions were in order to minimise the amount of logic the class contained. For example, although there are methods for setting the individual lamps on the various rows this is not retroactive. i.e. setting the third lamp to lit does not light the previous two. This logic has been left entirely up to the controller to enable and disable the lamps in any order as it sees fit.

I am taking advantage of dependency injection so, the view implementation also takes a PrintManager interface which allows the method for outputting the text to be chosen by the creating class. This acts as a benefit for testing but also means that the TextBerlinClockView could output to a Swing/AWT component or used to populate some other object.

One last mention should be made about the BerlinClockView where it needs additional methods to the constructor to be called prior to it's use. Although this can be considered an anti-pattern, I felt it was the way to go to ensure that responsibility for configuration of the view was left entirely up to the BerlinClockController.

The BerlinClockController conforms to the ClockController interface via the AbstractClockController. The methods that the ClockController define could be reused by other implementations of a Clock (digital/analogue representation) so it made use to make abstract versions. The methods defined by the abstract class help control the wrapping of values to conform to a 24 hour 60 minute 60 second clock representation.

The BerlinClockController itself handles all logic for initialising the view. Both the view and the ClockManager are passed to the controller (IoC) which allows it to load a configuration and configure the view. The ClockManager allows the controller to listen to any updates to the time and decide how it wants to handle this. This is a very loose implementation of the Observer/Observable design pattern. The intention here was rather than have each controller implement it's own thread for  updating itself as the time changed, the manager could be used as a single point for updates. This means that multiple clocks could all be assigned the same manager and be updated on the same thread. The BerlinClockController is also configurable and the length of the rows can be controlled so that the various rows can have different lengths and represent the time through various models.

The DefaultClockManager uses some very basic methods. Rather than concerning myself with Date/Calendar objects I simplified this to an array of integers. It may have been nicer to implement this as an object so that if further fields were intended to be displayed they could be added and retrieved through a clearer interface. It also allows the retrieval of the configuration used for configuring the controller, which in turn configures the view. The DefaultClockManager is returned by the ClockManagerFactory. Although the factory does nothing other than return the DefaultClockManager, it could be improved to load different clock managers through service location.

The configuration file itself takes use of the Builder pattern. This is an increasingly common pattern that allows the creation of immutable POJOs. It comes with further benefits such as validating the criteria prior to returning the intended POJO. Although there is no validation at the moment it could be utilised here to make sure that the rows would sensible related. The builder pattern also confers benefits such as being able to string all the variable assignments together on one line which is useful for example in constructors for classes extending another class where the first line must be a call to the super and the POJO could not be created before.

A commonly used helper class exists called the ArgumentHelper. This is a common pattern that I have been working with in my job and have begun using it in my own work. The ArgumentHelper takes arguments passed into methods and asserts their validity throwing exceptions in the case that they are invalid. This allows for the developer to easily identify the source of problems during development. Because these messages are not intended for the user they have not be put in a properties file. All strings throughout the application are intended for the developer and therefore I have not bothered to implement a properties file or the related loader.

Testing

There are tests for the majority of classes except those were testing was either difficult or provided little gain i.e the BerlinClock class is not tested. Due to the prolific use of the ArgumentHelper I wrote an ExceptionTester that provides a standard way of testing the common exceptions. Although JUnit comes with its own annotation for having tests pass when an expected exception is thrown, this is commonly abused and can lead to some situations where exceptions thrown for a different reason than the one being tested could cause the test to pass. It is important to test that the various exceptions are being thrown so that changes to the code do not change the business logic that was already implemented.

The most extensive tests are for the BerlinClockController and the TextBerlinClockView. The BerlinClockControllerTest extends the AbstractTestClockController for testing of the abstract methods without duplicating code. The AbstractTestClockController has been named different from the convention found everywhere else because some automated testing utilities such as surefire are set up so that they execute and file where 'Test' is found at the start or end of the filename and the inability to instantiate the class would cause a test error. The tests in this class prioritise the testing of edge cases.

I'm using Mockito a little in the BerlinClockController. Because many of the methods implemented on the view return void it is difficult to assert which values have been passed so I am also taking advantage of some mock class implementations, overriding the existing methods where necessary. This is not ideal and if I had more time I might have looked further into alternatives are revised my design patterns. I have tried to test edge cases as much as possible particularly around the wrapping of the midnight time. However I have implemented at least one test that cycles through the number of seconds in a day and makes sure the output from the controller is correct. I am also testing via the mock view class whether the values being passed to the view from the controller are as they should be.

Through use of the PrintManager interface the TextBerlinClockView become very easy to test and again, I test the cases that should throw exceptions before moving onto the logic cases.

The enum is tested via a switch statement which will throw an exception if an enum value has been added but no test case has been written. This reminds developers to ensure test cases are added.